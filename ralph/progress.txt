# Ralph Progress Log
# Branch: ralph/backend-query-optimization
# Started: 2026-01-13

## Codebase Patterns
- CountryJdbcRepository already has `findAllByIdIn(Set<Long> ids)` method with @Query annotation for batch loading
- InMemoryCountryRepository uses `java.util.*` wildcard import covering all collection types
- Port interfaces are in `application/port/`, JDBC adapters in `adapter/driven/jdbc/`, inmemory in `adapter/driven/inmemory/`
- Organisation domain stores CountryId (not Country), so asOrganisation() doesn't need to resolve Countries - just extract IDs
- OrganisationDbo.asOrganisation() accepts either resolver functions OR maps - use maps for batch loading
- EventOrganisationDbo.id is package-private, access with `eo.id.getId()` not via getter
- JdbcRepository.findAllById returns Iterable; use StreamSupport.stream(iter.spliterator(), false) to convert
- In @Query SQL, quote reserved keywords like `"primary"` for PostgreSQL compatibility
- For batch composite key lookups, build OR clauses: `(col1=:p1_0 AND col2=:p2_0) OR (col1=:p1_1 AND col2=:p2_1)` with indexed params
- Domain entities have DomainKey records (e.g., Person.DomainKey) for composite key uniqueness - use for Map keys

---

## 2026-01-13 23:48 - US-001
- Implemented `findAllById(Set<CountryId> ids)` in CountryRepositoryDataJdbcAdapter
- Implemented same method in InMemoryCountryRepository for test compatibility
- Returns `Map<CountryId, Country>` for efficient lookup
- Uses existing `countryJdbcRepository.findAllByIdIn(rawIds)` for batch query

**Files changed:**
- backend/src/main/java/de/jobst/resulter/adapter/driven/jdbc/CountryRepositoryDataJdbcAdapter.java
- backend/src/main/java/de/jobst/resulter/adapter/driven/inmemory/InMemoryCountryRepository.java

**Learnings for future iterations:**
- CountryJdbcRepository already had `findAllByIdIn` method prepared - check existing JdbcRepository methods before adding new ones
- The port interface (CountryRepository) already declared `findAllById` - it just needed implementation
- Always implement both JDBC and InMemory adapters when adding new repository methods
---

## 2026-01-13 23:52 - US-002
- Added overloaded `asOrganisation(Map<Long, Organisation>, Map<Long, Country>)` method to OrganisationDbo
- Added `batchLoadCountries()` helper method to OrganisationRepositoryDataJdbcAdapter
- Updated `findAll()` to use batch country loading instead of resolver function
- Fixed InMemoryOrganisationRepository.findAllById() to return proper map instead of null

**Files changed:**
- backend/src/main/java/de/jobst/resulter/adapter/driven/jdbc/OrganisationDbo.java
- backend/src/main/java/de/jobst/resulter/adapter/driven/jdbc/OrganisationRepositoryDataJdbcAdapter.java
- backend/src/main/java/de/jobst/resulter/adapter/driven/inmemory/InMemoryOrganisationRepository.java

**Learnings for future iterations:**
- OrganisationJdbcRepository.findAll() returns Collection, not List
- The resolver functions in asOrganisation() are currently unused since domain stores IDs not full objects
- Added both instance and static versions of asOrganisation with Maps for flexibility
---

## 2026-01-13 23:54 - US-003
- **Already completed in US-002** - The overloaded asOrganisation method was implemented ahead of schedule
- Verified: instance method `asOrganisation(Map<Long, Organisation>, Map<Long, Country>)` exists at line 104
- Verified: static method with same maps exists at line 117
- Verified: Original resolver-based methods remain at lines 83-102
- Compile and tests pass

**Files changed:** None (already done)

**Learnings for future iterations:**
- When implementing batch-loading patterns, the Map-accepting methods are often added together with the batch-loading logic
- Check if stories are already satisfied by previous work before implementing
---

## 2026-01-13 23:56 - US-004
- Updated `findAll(filter, pageable)` to use batch country loading instead of getCountryResolver()
- Updated `findAllById()` to use batch country loading
- Updated `findByIds()` to use batch country loading
- Now all findAll variants use the `batchLoadCountries()` helper for efficient Country loading

**Files changed:**
- backend/src/main/java/de/jobst/resulter/adapter/driven/jdbc/OrganisationRepositoryDataJdbcAdapter.java

**Learnings for future iterations:**
- The pattern is: collect DBOs, batch-load Countries with `batchLoadCountries()`, then use `asOrganisation(Collections.emptyMap(), countryMap)`
- Empty orgMap is fine because Organisation domain stores CountryId, not full Country objects
---

## 2026-01-13 23:58 - US-005
- Added Map-accepting overloads to EventDbo for batch Organisation loading
- Added `asEvents(Collection<EventDbo>, Map<Long, Organisation>)` static method
- Added `asEvent(EventDbo, Map<Long, Organisation>)` static method
- Added `asEvent(Map<Long, Organisation>)` instance method
- Original resolver-based methods remain unchanged

**Files changed:**
- backend/src/main/java/de/jobst/resulter/adapter/driven/jdbc/EventDbo.java

**Learnings for future iterations:**
- EventDbo follows same Map-accepting pattern as OrganisationDbo
- Event stores OrganisationIds (not full Organisation objects), so the Map parameter is for consistency but not strictly required for resolution
- The conversion logic is identical between resolver-based and Map-based methods - just different method signatures
---

## 2026-01-14 00:00 - US-006
- Added `batchLoadOrganisations(Collection<EventDbo>)` helper method to EventRepositoryDataJdbcAdapter
- Updated `findAll()` to use batch Organisation loading via the new helper
- Updated `findAllById()` to use batch Organisation loading
- Both methods now collect org IDs and batch-load with single query instead of N+1

**Files changed:**
- backend/src/main/java/de/jobst/resulter/adapter/driven/jdbc/EventRepositoryDataJdbcAdapter.java

**Learnings for future iterations:**
- EventOrganisationDbo.id is package-private, access it directly as `eo.id.getId()` (not via getter)
- OrganisationJdbcRepository.findAllById returns Iterable, use StreamSupport.stream() to convert to stream
- The batchLoadOrganisations pattern: collect IDs -> findAllById -> collect to Map<Long, Organisation>
---

## 2026-01-14 00:03 - US-007
- Optimized `findAll(filter, pageable)` to use batch-loading for both Organisations and EventCertificates
- Added `findPrimaryByEventIdIn(Set<Long> eventIds)` to EventCertificateJdbcRepository with @Query annotation
- Added `batchLoadPrimaryEventCertificates(Collection<EventDbo>)` helper method to EventRepositoryDataJdbcAdapter
- Now uses Map-based batch loading instead of N+1 resolver functions

**Files changed:**
- backend/src/main/java/de/jobst/resulter/adapter/driven/jdbc/EventCertificateJdbcRepository.java
- backend/src/main/java/de/jobst/resulter/adapter/driven/jdbc/EventRepositoryDataJdbcAdapter.java

**Learnings for future iterations:**
- PostgreSQL requires quoting `"primary"` in SQL because it's a reserved keyword
- Event.setCertificate(EventCertificateId) is the direct setter; use instead of withCertificate(Function) for batch loading
- EventCertificateDbo.getEvent() returns AggregateReference, call .getId() to get the Long value
---

## 2026-01-14 00:06 - US-008
- Optimized `findOrCreate(Collection<Person>)` to use batch existence checking with single composite query
- Added `batchFindExistingPersons()` method: builds SQL with OR clauses for each person's composite key (familyName, givenName, birthDate, gender)
- Added `batchInsertPersons()` helper for inserting new persons
- Now uses 1 query for existence check + N inserts only for new persons (instead of N queries for all)

**Files changed:**
- backend/src/main/java/de/jobst/resulter/adapter/driven/jdbc/PersonRepositoryDataJdbcAdapter.java

**Learnings for future iterations:**
- Person uniqueness requires composite key: (familyName, givenName, birthDate, gender)
- Person.DomainKey is a record that encapsulates this composite key - use it for Map keys
- For batch composite key lookups, build OR clauses dynamically: `(col1=:p1 AND col2=:p2) OR (col1=:p3 AND col2=:p4)`
- Handle NULL birthDate separately in SQL: use `birth_date IS NULL` when value is null
- PersonDbo has both static `asPerson(PersonDbo)` and instance `asPerson()` - use lambda `dbo -> dbo.asPerson()` to avoid ambiguous method reference
- Race uniqueness key is (eventId, raceNumber) - add DomainKey record and getDomainKey() method for batch operations
---

## 2026-01-14 00:09 - US-009
- Optimized `findOrCreate(Collection<Race>)` to use batch existence checking with single composite query
- Added `Race.DomainKey` record for (eventId, raceNumber) uniqueness key
- Added `getDomainKey()` method to Race domain entity
- Added `batchFindExistingRaces()` method: builds SQL with OR clauses for each race's composite key
- Added `batchInsertRaces()` helper for inserting new races
- Added `NamedParameterJdbcTemplate` dependency to RaceRepositoryDataJdbcAdapter
- Fixed InMemoryRaceRepository to use correct uniqueness key (eventId, raceNumber) instead of (raceName, raceNumber)

**Files changed:**
- backend/src/main/java/de/jobst/resulter/domain/Race.java
- backend/src/main/java/de/jobst/resulter/adapter/driven/jdbc/RaceRepositoryDataJdbcAdapter.java
- backend/src/main/java/de/jobst/resulter/adapter/driven/inmemory/InMemoryRaceRepository.java

**Learnings for future iterations:**
- Race uniqueness is (eventId, raceNumber), matching the JDBC `findByEventIdAndNumber` method
- InMemoryRaceRepository had a bug using raceName instead of eventId - always verify InMemory matches JDBC semantics
- Same DomainKey pattern as Person works for Race: add record + getDomainKey() method
---

## 2026-01-14 00:12 - US-010
- Optimized `findOrCreate(Collection<ResultList>)` to use batch existence checking with single composite query
- Added `ResultList.DomainKey` record for (eventId, raceId, creator, createTime) uniqueness key
- Added `getDomainKey()` method to ResultList domain entity
- Added `batchFindExistingResultLists()` method: builds SQL with OR clauses for each result list's composite key
- Added `batchInsertResultLists()` helper for inserting new result lists
- Added `NamedParameterJdbcTemplate` dependency to ResultListRepositoryDataJdbcAdapter
- Fixed InMemoryResultListRepository to use DomainKey instead of just (creator, createTime)

**Files changed:**
- backend/src/main/java/de/jobst/resulter/domain/ResultList.java
- backend/src/main/java/de/jobst/resulter/adapter/driven/jdbc/ResultListRepositoryDataJdbcAdapter.java
- backend/src/main/java/de/jobst/resulter/adapter/driven/inmemory/InMemoryResultListRepository.java

**Learnings for future iterations:**
- ResultList uniqueness key is (eventId, raceId, creator, createTime) - includes timezone handling
- InMemoryResultListRepository was missing eventId and raceId in uniqueness check - always verify InMemory matches JDBC semantics
- For nullable fields in composite keys (creator, createTime), use `IS NULL` in SQL when value is null
- Same DomainKey pattern as Person and Race works for ResultList
---

## 2026-01-16 13:45 - US-011
- Optimized `findOrCreate(Collection<SplitTimeList>)` to use batch existence checking with single composite query
- SplitTimeList.DomainKey record already existed for (eventId, resultListId, classResultShortName, personId, raceNumber)
- Added `batchFindExistingSplitTimeLists()` method: builds SQL with OR clauses for each split time list's composite key
- Added `batchInsertSplitTimeLists()` helper for inserting new split time lists
- Added `NamedParameterJdbcTemplate` dependency to SplitTimeListRepositoryDataJdbcAdapter
- Fixed InMemorySplitTimeListRepository.findOrCreate(Collection) to iterate and call single-entity findOrCreate
- Fixed InMemorySplitTimeListRepository.findOrCreate(SplitTimeList) to use DomainKey for proper uniqueness (was missing raceNumber)

**Files changed:**
- backend/src/main/java/de/jobst/resulter/adapter/driven/jdbc/SplitTimeListRepositoryDataJdbcAdapter.java
- backend/src/main/java/de/jobst/resulter/adapter/driven/inmemory/InMemorySplitTimeListRepository.java

**Learnings for future iterations:**
- SplitTimeList uniqueness key is (eventId, resultListId, classResultShortName, personId, raceNumber) - 5 fields
- SplitTimeList.DomainKey was already defined in the domain entity - no need to add it
- InMemorySplitTimeListRepository was missing raceNumber in uniqueness check and returned null for collection method
- Use `getDomainKey()` comparison for simpler InMemory implementations instead of multiple filter() calls
---

## 2026-01-16 14:00 - US-012
- Optimized Cup list operations to batch-load Events instead of N+1 queries
- Added overloaded `CupDto.from(Cup, Map<EventId, Event>)` method for batch conversion
- Updated `CupController.getAllCups()` to batch-load all Events for all Cups in one query
- Updated `CupController.searchCups()` paginated endpoint to batch-load Events for page
- Updated `CupController.createCupDetailedDto()` to batch-load Events
- Reduced queries from 1 + N (for N events) to just 2 queries total (1 for cups + 1 for all events)

**Files changed:**
- backend/src/main/java/de/jobst/resulter/adapter/driver/web/dto/CupDto.java
- backend/src/main/java/de/jobst/resulter/adapter/driver/web/CupController.java

**Learnings for future iterations:**
- The N+1 issue was in the controller/DTO layer, not the repository layer
- CupDto.from() was calling eventService.getById() for each EventId (N+1 pattern)
- EventService.findAllById() returns List<Event>, need to convert to Map with Collectors.toMap()
- Cup domain only stores EventIds, not full Events - batch loading happens at presentation layer
- EventKeyDto only needs id, name, startTime - no Organisation loading needed for Cup lists
---

